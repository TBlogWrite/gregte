<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>D√¢y √¥m vi√™n bi (anchor g·∫ßn nhau)</title>
  <style>

    body {
        background: #111;
        display: flex;
        flex-direction: column;
        justify-content: flex-start; /* tr√™n mobile, b·∫Øt ƒë·∫ßu t·ª´ tr√™n */
        align-items: center;
        margin: 0;
        padding: 10px; /* tr√°nh s√°t m√©p m√†n h√¨nh */
      }
      
      canvas {
        background: #000;
        margin: 10px 0;
        width: 100%;          /* full width m√†n h√¨nh */
        max-width: 600px;     /* gi·ªõi h·∫°n r·ªông cho desktop */
        height: auto;         /* t·ª± ƒë·ªông theo t·ª∑ l·ªá */
        aspect-ratio: 3/2;    /* gi·ªØ t·ªâ l·ªá 600x400 */
        cursor: grab;
    }
      
      .btns {
        display: flex;
        flex-wrap: wrap;      /* n·∫øu m√†n h√¨nh nh·ªè, xu·ªëng h√†ng */
        gap: 6px;
        margin-bottom: 10px;
      }
      
      button {
        padding: 6px 10px;
        font-size: 14px;
      }

  </style>
</head>
<body>

<canvas id="b" width="600" height="400"></canvas>
<br/>
<div class="btns">
    <button onclick="manualMode=true;mode='bottom';draw()">√îm d∆∞·ªõi</button>
    <button onclick="manualMode=true;mode='top';draw()">√îm tr√™n</button>
  </div>
<canvas id="c" width="600" height="400"></canvas>
<script>
const canvasb = document.getElementById("b");
const canvasc = document.getElementById("c");
const ctx1 = canvasb.getContext("2d");
const ctx2 = canvasc.getContext("2d");


function drawCurves() {
    ctx1.clearRect(0,0,canvasb.width,canvasb.height);
    const cx = canvasb.width/2;
    const cy = canvasb.height/2;
    const H = 250;    // chi·ªÅu cao
    const R = 200;    // b√°n k√≠nh c∆° b·∫£n
    const numLines = 80; // s·ªë ƒë∆∞·ªùng (tƒÉng/gi·∫£m tu·ª≥ √Ω)
  
    for (let i=0; i<numLines; i++){
        ctx1.beginPath();
        ctx1.strokeStyle = "lime";
        ctx1.lineWidth = 1;
  
      const angle = (i / numLines) * 2*Math.PI; // chia ƒë·ªÅu xung quanh
  
      for (let t=-1; t<=1; t+=0.01){
        const y = cy + t*H/2;
        // b√°n k√≠nh nh·ªè nh·∫•t ·ªü gi·ªØa (t=0)
        const r = R * (1 - 0.6*Math.exp(-6*t*t));
        const x = cx + r * Math.cos(angle);
        ctx1.lineTo(x, y);
      }
  
      ctx1.stroke();
    }
  }
  const cx = canvasb.width/2;
const cy = canvasb.height/2;
const H = 250;    // chi·ªÅu cao
const R = 200;    // b√°n k√≠nh c∆° b·∫£n
const numLines = 80; // s·ªë ƒë∆∞·ªùng cong

let tBall = -1;   // v·ªã tr√≠ vi√™n bi theo tr·ª•c (-1 tr√™n, 0 gi·ªØa, 1 d∆∞·ªõi)
let speed = 0.01; // t·ªëc ƒë·ªô r∆°i
  function drawBall() {
    // to·∫° ƒë·ªô vi√™n bi theo tBall
    const y = cy + tBall * H/2;
    const r = R * (1 - 0.6*Math.exp(-6*tBall*tBall)); 
    const x = cx; // cho bi ·ªü gi·ªØa tr·ª•c
  
    // b√°n k√≠nh vi√™n bi: l·ªõn ·ªü tr√™n/d∆∞·ªõi, nh·ªè nh·∫•t ·ªü gi·ªØa
    const ballRadius = 15 * (1 - 0.7*Math.exp(-6*tBall*tBall));
  
    ctx1.beginPath();
    ctx1.fillStyle = "red";
    ctx1.arc(x, y, ballRadius, 0, 2*Math.PI);
    ctx1.fill();
  }
  
  function animate2() {
    ctx1.clearRect(0,0,canvasb.width,canvasb.height);
    drawCurves();
    drawBall();
  
    tBall += speed;
    if (tBall > 1) tBall = -1; // l·∫∑p l·∫°i
  
    requestAnimationFrame(animate2);
  }

  animate2();
  
drawCurves();

let ball = {x:300, y:220, r:27.75};
// 2 ƒëi·ªÉm anchor g·∫ßn nhau
let anchor1 = {x:270, y:80};
let anchor2 = {x:330, y:80};

let dragTarget = null;
let modeToUse;
let manualMode = true;
let mode = 'bottom'; // ho·∫∑c 'top'

function draw(){
    ctx2.clearRect(0,0,canvasc.width,canvasc.height);
  
    // V·∫Ω bi
    ctx2.beginPath();
    ctx2.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
    ctx2.fillStyle="red";
    ctx2.fill();
  
    let tx1,ty1,tx2,ty2,a1,a2;
    let t = 0.8; // ƒë·ªô cong

    let arcClockwise;

    console.log(manualMode);

    if (manualMode) {
        modeToUse = mode; // d√πng mode do button ch·ªçn
    } else {
        modeToUse = (ball.x < canvasc.width/2) ? "top" : "bottom"; // t·ª± ƒë·ªông
    }
  
    if (modeToUse==="top"){ 
      a1 = Math.PI * 1.25;   // 225¬∞
      a2 = Math.PI * 1.75;   // 315¬∞
    } else {
      a1 = Math.PI * 1.0625;   // 191.25¬∞
      a2 = Math.PI * 1.9375;   // 348.75¬∞
    }
  
    tx1 = ball.x + ball.r * Math.cos(a1);
    ty1 = ball.y + ball.r * Math.sin(a1);
    tx2 = ball.x + ball.r * Math.cos(a2);
    ty2 = ball.y + ball.r * Math.sin(a2);
  
    // H√†m l·∫•y midpoint u·ªën cong
    function getMid(x1,y1,x2,y2,cx,cy,t){
      let mx=(x1+x2)/2, my=(y1+y2)/2;
      mx = mx*(1-t)+cx*t;
      my = my*(1-t)+cy*t;
      return {x:mx,y:my};
    }
  
    ctx2.beginPath();
    ctx2.moveTo(anchor1.x, anchor1.y);
  
    // --- u·ªën cong ti·∫øp tuy·∫øn tr√°i v·ªõi anchor1 ---
    let mid1 = getMid(anchor1.x, anchor1.y, tx1, ty1, ball.x, ball.y, t);
    ctx2.quadraticCurveTo(mid1.x, mid1.y, tx1, ty1);
  
    // --- v·∫Ω cung tr√≤n quanh bi ---
    ctx2.arc(ball.x, ball.y, ball.r, a1, a2, modeToUse==="top"?false:true);
  
    // --- u·ªën cong ti·∫øp tuy·∫øn ph·∫£i v·ªõi anchor2 ---
    let mid2 = getMid(anchor2.x, anchor2.y, tx2, ty2, ball.x, ball.y, t);
    ctx2.quadraticCurveTo(mid2.x, mid2.y, anchor2.x, anchor2.y);
  
    ctx2.strokeStyle="white";
    ctx2.lineWidth=2;
    ctx2.stroke();
  
    // v·∫Ω anchor
    ctx2.fillStyle="cyan";
    [anchor1, anchor2].forEach(a=>{
      ctx2.beginPath();
      ctx2.arc(a.x,a.y,5,0,Math.PI*2);
      ctx2.fill();
    });

// --- v·∫Ω time line xanh l√° d√†i v√¥ t·∫≠n ---
ctx2.beginPath();
let timeLineCurrY = (anchor1.y + anchor2.y) / 2; // ngang gi·ªØa hai anchor
ctx2.moveTo(0, timeLineCurrY);             // b·∫Øt ƒë·∫ßu t·ª´ c·ª±c tr√°i canvasc
ctx2.lineTo(canvasc.width, timeLineCurrY); // k√©o d√†i t·ªõi c·ª±c ph·∫£i canvasc
ctx2.strokeStyle = "lime"; // m√†u xanh l√°
ctx2.lineWidth = 2;
ctx2.stroke();

// --- v·∫Ω ch·ªØ tr√™n time line ---
ctx2.fillStyle = "lime";
ctx2.font = "16px monospace";
ctx2.textAlign = "left";        // ch·ªØ n·∫±m b√™n tr√°i
ctx2.textBaseline = "bottom";   // ch·ªØ n·∫±m tr√™n line
ctx2.fillText("time line current", 5, timeLineCurrY - 2);

// --- v·∫Ω time line ---
// ctx2.beginPath();
// let timeLineY = ball.y + ball.r + 10; // v·ªã tr√≠ line
// // ƒêi·ªÉm v√†ng
// let points = [
//   {x:0, y:timeLineY},   // 1
//   {x:ball.x - 100, y:timeLineY},  // 2
//   {x:ball.x, y:timeLineY},  // 3
//   {x:ball.x + 100, y:timeLineY},  // 4
// ];
// 
// let amplitude = 40; // ƒë·ªô cong xu·ªëng cho ƒëo·∫°n 2->4
// 
// ctx2.strokeStyle="white";
// ctx2.lineWidth=2;
// ctx2.beginPath();
// 
// // 1 -> 2 th·∫≥ng
// ctx2.moveTo(points[0].x, points[0].y);
// ctx2.lineTo(points[1].x, points[1].y);
// 
// // 2 -> 4 cong xu·ªëng (b·ªè qua ƒëi·ªÉm 3)
// let midX = (points[1].x + points[3].x)/2;
// let midY = (points[1].y + points[3].y)/2 + amplitude;
// ctx2.moveTo(points[1].x, points[1].y);
// ctx2.quadraticCurveTo(midX, midY, points[3].x, points[3].y);
// 
// // 4 -> d√†i v√¥ h·∫°n v·ªÅ ph·∫£i
// ctx2.moveTo(points[3].x, points[3].y);
// ctx2.lineTo(canvasc.width + 1000, points[3].y); // k√©o d√†i v√¥ h·∫°n v·ªÅ b√™n ph·∫£i
// 
// ctx2.stroke();
// ctx2.moveTo(0, timeLineY);
// ctx2.lineTo(canvasc.width, timeLineY);
// ctx2.strokeStyle = "white";
// ctx2.lineWidth = 1;
// ctx2.stroke();

// --- v·∫Ω ch·ªØ tr√™n time line ---
// --- v·∫Ω ch·ªØ tr√™n time line b√™n tr√°i ---

ctx2.fillStyle = "white";
ctx2.font = "16px monospace";    // font mono
ctx2.textAlign = "left";         // cƒÉn tr√°i
ctx2.textBaseline = "bottom";    // n·∫±m tr√™n line
ctx2.fillText("time line absorb", 5, timeLineY - 2); // 5px c√°ch m√©p tr√°i


}


let gorilla = { x: 0, speed: 2 };

// --- time line ---
let timeLineY = ball.y + ball.r + 10;
let points = [
  {x:0, y:timeLineY},           
  {x:ball.x - 100, y:timeLineY}, 
  {x:ball.x, y:timeLineY},       
  {x:ball.x + 100, y:timeLineY}, 
];
let amplitude = 40; // ƒë·ªô cong xu·ªëng cho ƒëo·∫°n 2->4


function getTimeLinePoints(ballX, timeLineY, canvasWidth) {
    const offset = canvasWidth * 0.16; // ~100px khi width=600, t·ª∑ l·ªá responsive
    return [
        { x: 0, y: timeLineY },                 
        { x: Math.max(ballX - offset, 0), y: timeLineY },  
        { x: ballX, y: timeLineY },                  
        { x: Math.min(ballX + offset, canvasWidth), y: timeLineY }, 
    ];
}

// H√†m v·∫Ω ƒë∆∞·ªùng time line
function drawTimeLine() {
    draw();

    timeLineY = ball.y + ball.r + 10;
    draw(); // v·∫Ω bi v√† c√°c d√¢y

    timeLineY = ball.y + ball.r + 10;
    points = getTimeLinePoints(ball.x, timeLineY, canvasc.width);

    ctx2.strokeStyle="white";
    ctx2.lineWidth=2;

    // 1 -> 2 th·∫≥ng
    ctx2.beginPath();
    ctx2.moveTo(points[0].x, points[0].y);
    ctx2.lineTo(points[1].x, points[1].y);
    ctx2.stroke();

    // 2 -> 4 cong xu·ªëng (b·ªè qua ƒëi·ªÉm 3)
    let midX = (points[1].x + points[3].x)/2;
    let midY = (points[1].y + points[3].y)/2 + amplitude;
    ctx2.beginPath();
    ctx2.moveTo(points[1].x, points[1].y);
    ctx2.quadraticCurveTo(midX, midY, points[3].x, points[3].y);
    ctx2.stroke();

    // 4 -> d√†i v√¥ h·∫°n v·ªÅ ph·∫£i
    ctx2.beginPath();
    ctx2.moveTo(points[3].x, points[3].y);
    ctx2.lineTo(canvasc.width + 1000, points[3].y);
    ctx2.stroke();
}

// H√†m l·∫•y y tr√™n ƒë∆∞·ªùng time line theo x
function getYOnLine(x) {
  if(x <= points[1].x) {
    // ƒëo·∫°n 1->2 th·∫≥ng
    return points[0].y;
  } else if(x <= points[3].x) {
    // ƒëo·∫°n 2->4 cong
    let t = (x - points[1].x)/(points[3].x - points[1].x);
    let midX = (points[1].x + points[3].x)/2;
    let midY = (points[1].y + points[3].y)/2 + amplitude;
    // quadratic B√©zier
    let y = (1-t)*(1-t)*points[1].y + 2*(1-t)*t*midY + t*t*points[3].y;
    return y;
  } else {
    // ƒëo·∫°n d√†i v√¥ h·∫°n
    return points[3].y;
  }
}

// Animate gorilla
function animate() {
  ctx2.clearRect(0,0,canvasc.width,canvasc.height);
  
  drawTimeLine();
  
  let y = getYOnLine(gorilla.x);
  ctx2.font = "32px monospace";
  ctx2.textAlign = "center";
  ctx2.textBaseline = "middle";
  ctx2.fillText("ü¶ç", gorilla.x, y);
  
  gorilla.x += gorilla.speed;
  if(gorilla.x > canvasc.width + 32) gorilla.x = -32; // l·∫∑p l·∫°i
  
  requestAnimationFrame(animate);
}

animate();

// --- Drag logic ---
canvasc.addEventListener("mousedown", e=>{
  const mx = e.offsetX, my = e.offsetY;
  if (Math.hypot(mx-ball.x, my-ball.y) < ball.r) dragTarget=ball;
});
canvasc.addEventListener("mousemove", e=>{
    if (dragTarget){
      dragTarget.x = e.offsetX;
      dragTarget.y = e.offsetY;
      manualMode = false; // t·ª± ƒë·ªông khi k√©o
      draw();
    }
  });
canvasc.addEventListener("mouseup", ()=>dragTarget=null);
</script>
</body>
</html>
