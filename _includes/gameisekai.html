<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Game Ise cai</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            margin: 0;
            background: #111;
            overflow: hidden;
        }

        canvas {
            display: block;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

</head>

<body>
    <div class="modal fade" id="storyModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
          <div class="modal-content bg-dark text-white">
            <div class="modal-header">
              <h5 class="modal-title">V≈© tr·ª• m·ªõi l√†m l·∫°i t·ª´ ƒë·∫ßu !</h5>
              <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body" id="storyText">
              
            </div>
            <div class="modal-body" id="storyTextFun">
                It‚Äôs so fun !!!! (Creater ChatGPT)
            </div>
            <div class="modal-footer">
              <button id="startButton" type="button" class="btn btn-primary" data-bs-dismiss="modal">ƒê√≥ng</button>
            </div>
          </div>
        </div>
      </div>
      
    <canvas id="game"></canvas>
    <script>

        let gameStart = true;
        window.addEventListener("DOMContentLoaded", () => {
            // G√°n n·ªôi dung ban ƒë·∫ßu
            document.getElementById("storyText").innerText = "Ch√†o m·ª´ng ƒë·∫øn v·ªõi th·∫ø gi·ªõi ƒë√£ isekai !\n - Sau m·ªôt ng√†y your bu·ªìn b·∫£ t·ª´ name.\n - B·∫°n ise cai th√¨ th·∫ßn ti√™n cho b·∫°n qua th·∫ø gi·ªõi m·ªõi.\n" + 
                "- M·ªôt ng√†y, t√¥i b·∫•t ng·ªù b·ªã xuy√™n kh√¥ng sang m·ªôt th·∫ø gi·ªõi xa l·∫°, n∆°i ch√¢n t√¥i d√†i ra b·∫•t th∆∞·ªùng v√† √°nh m·∫Øt m·ªçi ng∆∞·ªùi tr·∫ßm tr·ªì. Ch·∫≥ng bi·∫øt t·∫°i sao, t√¥i b·ªã quƒÉng th·∫≥ng v√†o luy·ªán ng·ª•c ch·∫øt ch√≥c, n∆°i qu√°i v·∫≠t g·∫ßm th√©t, b·∫´y r√¨nh r·∫≠p kh·∫Øp n∆°i. Nh∆∞ng v·ªõi √Ω ch√≠ v√† ch√∫t may m·∫Øn, t√¥i v∆∞·ª£t qua m·ªçi nguy hi·ªÉm, luy·ªán ƒë∆∞·ª£c b√≠ k√≠p t·ªëi th∆∞·ª£ng khi·∫øn thi√™n h·∫° ph·∫£i khi·∫øp s·ª£.\n"
            +   "- Trong h√†nh tr√¨nh ƒëi√™n r·ªì n√†y, t√¥i g·∫∑p ng∆∞·ªùi ·∫•y ‚Äî m·ªôt b√≥ng h·ªìng v·ª´a b√≠ ·∫©n v·ª´a m·∫°nh m·∫Ω, khi·∫øn tim t√¥i lo·∫°n nh·ªãp. Kh√¥ng d·ª´ng l·∫°i ·ªü ƒë√≥, t√¥i c√≤n g·∫∑p nh·ªØng ƒë·ªìng minh k·ª≥ l·∫°: t·ª´ ma n·ªØ l·∫°nh l√πng, hi·ªáp sƒ© m·∫°nh m·∫Ω, ƒë·∫øn ph√°p s∆∞ ng·ªï ng√°o, t·∫•t c·∫£ ƒë·ªÅu b·ªã cu·ªën v√†o harem nh·ªè nh∆∞ng‚Ä¶ ƒë·∫ßy h·ªón lo·∫°n c·ªßa t√¥i!\n"
            +   "- Gi·ªØa nh·ªØng tr·∫≠n chi·∫øn n·∫£y l·ª≠a, nh·ªØng √¢m m∆∞u ƒëen t·ªëi, v√† nh·ªØng ph√©p thu·∫≠t √°nh sao lung linh, t√¥i b∆∞·ªõc ƒëi, t·ªèa s√°ng nh∆∞ √°nh sao duy nh·∫•t tr√™n b·∫ßu tr·ªùi, ch·ª©ng minh r·∫±ng: kh√¥ng ai c√≥ th·ªÉ ngƒÉn c·∫£n t√¥i vi·∫øt n√™n c√¢u chuy·ªán huy·ªÅn tho·∫°i c·ªßa ri√™ng m√¨nh."
            ;
            document.getElementById("startButton").addEventListener("click", () => {
                gameStart = false;
            });
            // L·∫•y modal v√† hi·ªÉn th·ªã
            const storyModal = new bootstrap.Modal(document.getElementById("storyModal"));
            storyModal.show();
        });

        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");

        // cho canvas full m√†n h√¨nh
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        //window.addEventListener("resize", () => {
        //  canvas.width = window.innerWidth;
        //  canvas.height = window.innerHeight;
        //});

        // Ng∆∞·ªùi que
        let player = {
            x: canvas.width / 2,
            y: canvas.height - 60,
            vy: 0,
            gravity: 0.5,
            jumpPower: -10,
            onGround: true
        };

        // C√°c h·ªôp bay qua l·∫°i
        let obstacles = [];
        function createObstacle(y) {
            let width = 120;
            let x = Math.random() < 0.5 ? 0 : canvas.width - width;
            obstacles.push({
                x: x,
                y: y,
                w: width,
                h: 20,
                dir: x === 0 ? 1 : -1
            });
        }

        const skills = [
            "C·ª≠u Chuy·ªÉn Huy·ªÅn C√¥ng",
            "Nh·∫•t Ki·∫øm Kinh Thi√™n",
            "Ng≈© L√¥i Oanh ƒê·ªânh",
            "Th√°i H∆∞ Luy·ªán Th·ªÉ Quy·∫øt",
            "V·∫°n Ki·∫øm Quy T√¥ng",
            "Ch√¢n Long H√≥a Th√¢n",
            "ƒê·∫°i Nh·∫≠t Nh∆∞ Lai Ch∆∞·ªüng",
            "√Çm D∆∞∆°ng Nh·ªã Kh√≠ Lu√¢n",
            "C·ª≠u U Ma Di·ªÖm Quy·∫øt",
            "Huy·∫øt Th·∫ßn T·ª≠ Luy·ªán ƒê·∫°i Ph√°p"
        ];

        function createObstacles() {
            obstacles = [];
            for (let i = 0; i < skills.length; i++) {
                createObstacle(canvas.height - (i + 1) * 150);
            }
        }

        createObstacles();

        window.addEventListener("resize", () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            createObstacles(); // t·∫°o l·∫°i ƒë·ªß 10 h·ªôp
        });

        function drawIsoscelesTriangle(x, y, size) {
            ctx.beginPath();
            ctx.moveTo(x, y + size);              // ƒë·ªânh d∆∞·ªõi
            ctx.lineTo(x - size * 0.75, y - size);// g√≥c tr√°i
            ctx.lineTo(x + size * 0.75, y - size);// g√≥c ph·∫£i
            ctx.closePath();
            ctx.stroke();
        }


        let longtail = 50;
        // V·∫Ω ng∆∞·ªùi que
        function drawStickman(x, y) {
            ctx.strokeStyle = "white";
            ctx.lineWidth = 4;

            // ƒë·∫ßu
            drawIsoscelesTriangle(x, y - 30, 15);

            // th√¢n
            ctx.beginPath();
            ctx.moveTo(x, y - 15);
            ctx.lineTo(x, y + 25);
            ctx.stroke();

            // tay
            ctx.beginPath();
            ctx.moveTo(x, y - 5);
            ctx.lineTo(x - 20, y + 10);
            ctx.moveTo(x, y - 5);
            ctx.lineTo(x + 20, y + 10);
            ctx.stroke();

            // ch√¢n
            ctx.beginPath();
            ctx.moveTo(x, y + 25);
            ctx.lineTo(x - 15, y + longtail); // ch√¢n tr√°i
            ctx.moveTo(x, y + 25);
            ctx.lineTo(x + 15, y + longtail); // ch√¢n ph·∫£i
            ctx.stroke();
        }

        // ƒêi·ªÅu khi·ªÉn: nh·∫£y
        window.addEventListener("keydown", (e) => {
            if ((e.code === "Space" || e.code === "ArrowUp") && player.onGround) {
                player.vy = player.jumpPower;
                player.onGround = false;
            }
        });

        let gameOver = false;


        function drawSkillBoxes() {
            ctx.font = "16px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            skills.forEach((skill, i) => {
                let x = 150;
                let y = 50 + i * 50; // m·ªói √¥ c√°ch nhau 50px
                let w = 300;
                let h = 40;

                // V·∫Ω h·ªôp ƒë·ªè
                ctx.fillStyle = "red";
                ctx.fillRect(x, y, w, h);

                // V·∫Ω vi·ªÅn
                ctx.strokeStyle = "black";
                ctx.strokeRect(x, y, w, h);

                // Vi·∫øt ch·ªØ tr·∫Øng
                ctx.fillStyle = "white";
                ctx.fillText(skill, x + w / 2, y + h / 2);
            });
        }

        let particles = [];

        function spawnSmoke(x, y) {
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: x + Math.random() * 20 - 10,
                    y: y + Math.random() * 20 - 10,
                    vx: (Math.random() - 0.5) * 1,
                    vy: -Math.random() * 1.5 - 0.5,
                    alpha: 1,
                    radius: Math.random() * 6 + 4
                });
            }
        }

        function updateSmoke(ctx) {
            particles.forEach((p, i) => {
                p.x += p.vx;
                p.y += p.vy;
                p.alpha -= 0.02;
                if (p.alpha <= 0) particles.splice(i, 1);

                ctx.beginPath();
                ctx.fillStyle = `rgba(255,255,255,${p.alpha})`;
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Ch·ªçn ki·ªÉu ƒë·∫ßu ng·∫´u nhi√™n: "circle" ho·∫∑c "triangle"
        const headType = Math.random() < 0.5 ? "circle" : "triangle";
        let collisionCount = 0; // ƒë·∫øm s·ªë va ch·∫°m
        function drawCharacterƒê·∫±ng·∫§y(x, y) {
            ctx.strokeStyle = "white";
            ctx.lineWidth = 3;

            // V·∫Ω ƒë·∫ßu
            if (headType === "circle") {
                // V·∫Ω ƒë·∫ßu tr√≤n, radius nh·ªè h∆°n
                const radius = 13; // gi·∫£m t·ª´ 15 ‚Üí 10
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.stroke();
            } else {
                const size = 10; // gi·∫£m t·ª´ 10 ‚Üí 8
                ctx.beginPath();
                ctx.moveTo(x, y + size + 9);        // ƒë·ªânh d∆∞·ªõi
                ctx.lineTo(x - size, y - size); // g√≥c tr√°i tr√™n
                ctx.lineTo(x + size, y - size); // g√≥c ph·∫£i tr√™n
                ctx.closePath();
                ctx.stroke();
            }

            // Th√¢n
            ctx.beginPath();
            ctx.moveTo(x, y + 15);
            ctx.lineTo(x, y + 60);
            ctx.stroke();

            // V√°y (tam gi√°c c√¢n)
            ctx.beginPath();
            ctx.moveTo(x - 20, y + 60);  // g√≥c tr√°i
            ctx.lineTo(x + 20, y + 60);  // g√≥c ph·∫£i
            ctx.lineTo(x, y + 30);       // ƒë·ªânh v√°y
            ctx.closePath();
            ctx.stroke();
            ctx.fillStyle = "white";      // m√†u v√°y
            ctx.fill();

            // Tay
            ctx.beginPath();
            ctx.moveTo(x, y + 25);
            ctx.lineTo(x - 25, y + 40);
            ctx.moveTo(x, y + 25);
            ctx.lineTo(x + 25, y + 40);
            ctx.stroke();

            // Ch√¢n
            ctx.beginPath();
            ctx.moveTo(x, y + 60);
            ctx.lineTo(x - 15, y + 90);
            ctx.moveTo(x, y + 60);
            ctx.lineTo(x + 15, y + 90);
            ctx.stroke();

            // V·∫Ω b·ªá ·ªü g√≥c ph·∫£i tr√™n c√πng
        }
        function drawHUD() {
            // T·∫°o hi·ªáu ·ª©ng m√†u nh·∫•p nh√°y theo th·ªùi gian
            let t = Date.now() / 300; // t·ªëc ƒë·ªô ƒë·ªïi m√†u
            let r = Math.floor(128 + 127 * Math.sin(t));
            let g = Math.floor(128 + 127 * Math.sin(t + 2));
            let b = Math.floor(128 + 127 * Math.sin(t + 4));
            let color = `rgb(${r},${g},${b})`;

            ctx.fillStyle = color;
            ctx.font = "bold 24px Arial";
            ctx.fillText("L·ª•m ƒë∆∞·ª£c b√≠ k√≠p: " + collisionCount, 120, 40);
        }

        function drawZoom() {
            // T·∫°o hi·ªáu ·ª©ng m√†u nh·∫•p nh√°y theo th·ªùi gian
            let t = Date.now() / 300; // t·ªëc ƒë·ªô ƒë·ªïi m√†u
            let r = Math.floor(128 + 127 * Math.sin(t));
            let g = Math.floor(128 + 127 * Math.sin(t + 2));
            let b = Math.floor(128 + 127 * Math.sin(t + 4));
            let color = `rgb(${r},${g},${b})`;

            ctx.fillStyle = color;
            ctx.font = "bold 24px Arial";
            ctx.textAlign = "right";   // cƒÉn ph·∫£i
            ctx.fillText("N·∫øu kh√¥ng nh√¨n th·∫•y nh·ªõ zoom out nghe !", canvas.width - 20, 40);
        }

        let gameEnded = false;
        function checkEndCondition() {
            if (!gameEnded && Math.abs(player.y - npc.y) < 5) {
                gameEnded = true;
                alert("üéâ B·∫°n ƒë√£ t√¨m ƒë∆∞·ª£c ƒë·∫±ng ·∫•y ! Th·∫ø gi·ªõi b·∫°n ƒë√£ isekai qua ƒë√£ OK!");
            }
        }

        let platformW = 120;
        let platformH = 20;
        let platformX = canvas.width - platformW - 20;
        let platformY = 180;

        let npc = {
            x: platformX + platformW / 2,
            y: platformY - 90
        }

        let thanhTien = false;
        let lastCollision = false; // c·ªù l∆∞u tr·∫°ng th√°i va ch·∫°m tr∆∞·ªõc ƒë√≥
        function update() {

            if (gameStart) {
                requestAnimationFrame(update);
                return; // game ch∆∞a b·∫Øt ƒë·∫ßu
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!gameOver) {
                // v·∫≠t l√Ω nh√¢n v·∫≠t
                player.y += player.vy;
                player.vy += player.gravity;

                // ch·∫°m ƒë·∫•t
                let groundLevel = canvas.height - 60 - longtail * 1; // t√πy t·ªâ l·ªá
                if (player.y >= groundLevel) {
                    player.y = groundLevel;
                    player.vy = 0;
                    player.onGround = true;
                }

                // v·∫Ω ng∆∞·ªùi que
                drawStickman(player.x, player.y);

                ctx.fillStyle = "gray";
                ctx.fillRect(platformX, platformY, platformW, platformH);
                drawCharacterƒê·∫±ng·∫§y(npc.x, npc.y);
                drawHUD();
                drawZoom();

                obstacles.forEach((obs, i) => {
                    // di chuy·ªÉn
                    obs.x += 3 * obs.dir;
                    if (obs.x < 0 || obs.x + obs.w > canvas.width) obs.dir *= -1;

                    // v·∫Ω h·ªôp tr·∫Øng m·ªù
                    ctx.fillStyle = "rgba(255,255,255,0.7)";
                    let scale = 1.5; // ph√≥ng to 150%
                    ctx.fillRect(
                        obs.x - (obs.w * (scale - 1)) / 2,  // d·ªãch tr√°i ƒë·ªÉ h·ªôp n·ªü ƒë·ªÅu 2 b√™n
                        obs.y - (obs.h * (scale - 1)) / 2,  // d·ªãch l√™n ƒë·ªÉ h·ªôp n·ªü ƒë·ªÅu 2 ph√≠a
                        obs.w * scale,
                        obs.h * scale
                    );

                    // spawn kh√≥i ·ªü tr√™n h·ªôp
                    spawnSmoke(obs.x + obs.w / 2, obs.y);

                    // v·∫Ω ch·ªØ v√µ c√¥ng
                    ctx.fillStyle = "black";
                    ctx.font = "14px Arial";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    let skill = skills[i % skills.length];
                    ctx.fillText(skill, obs.x + obs.w / 2, obs.y + obs.h / 2);
                    let thanhTien = false;
                    // ki·ªÉm tra va ch·∫°m
                    if (
                        player.x > obs.x &&
                        player.x < obs.x + obs.w &&
                        player.y > obs.y - 10 &&
                        player.y < obs.y + obs.h + 40
                    ) {
                        longtail += 25 ;
                        player.y -= 100;
                        thanhTien = true;
                        if (!lastCollision) {
                            collisionCount += 1;
                            lastCollision = true;
            
                        }
                    }

                });
                if (!thanhTien) lastCollision = false;
                // ch·ªâ tƒÉng collisionCount ƒë√∫ng 1 l·∫ßn khi va ch·∫°m m·ªõi x·∫£y ra
                checkEndCondition();

                // sau khi v·∫Ω obstacles, v·∫Ω hi·ªáu ·ª©ng kh√≥i
                updateSmoke(ctx);
            } else {
                ctx.fillStyle = "yellow";
                ctx.font = "bold 48px Arial";
                ctx.fillText("GAME OVER", canvas.width / 2 - 120, canvas.height / 2);
            }

            requestAnimationFrame(update);
        }
        update();
    </script>
</body>

</html>