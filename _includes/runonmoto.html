<!doctype html>
<html lang="vi">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Ng∆∞·ªùi que l√°i xe m√°y - Animation</title>
    <style>
        /* Reset c∆° b·∫£n */
        html,
        body {
            height: 100%;
            margin: 0;
            background: linear-gradient(#87CEEB, #BFE9FF);
        }

        #stage {
            display: block;
            width: 100%;
            height: 100vh;
        }

        /* Th√¥ng tin h∆∞·ªõng d·∫´n nh·ªè */
        .ui {
            position: fixed;
            left: 12px;
            top: 12px;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px 10px;
            border-radius: 8px;
            font-family: Inter, Arial, sans-serif;
            font-size: 14px;
            color: #222;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1)
        }

        /* N√∫t ƒëi·ªÅu khi·ªÉn */
        .btn {
            margin-left: 8px;
            padding: 6px 10px;
            border-radius: 6px;
            border: none;
            background: #2b7cff;
            color: white;
            cursor: pointer
        }

        .btn:active {
            transform: translateY(1px)
        }
    </style>
</head>

<body>
    <div class="ui">Nh·∫•n <button class="btn" id="toggle">T·∫°m d·ª´ng</button> t·ªëc ƒë·ªô: <input id="speed" type="range"
            min="1" max="6" value="3" /> <span id="spdVal">3</span></div>
    <canvas id="stage"></canvas>

    <script>
        // M√¥ t·∫£: animation canvas ƒë∆°n gi·∫£n. Ng∆∞·ªùi que + xe m√°y ch·∫°y ngang qua nhi·ªÅu ng√¥i nh√†.
        // T·∫•t c·∫£ trong 1 file, d·ªÖ ch·ªânh s·ª≠a.

        const canvas = document.getElementById('stage');
        const ctx = canvas.getContext('2d');
        let W = canvas.width = innerWidth;
        let H = canvas.height = innerHeight;

        window.addEventListener('resize', () => {
            W = canvas.width = innerWidth;
            H = canvas.height = innerHeight;
        });

        // C·∫•u h√¨nh
        const roadY = Math.floor(H * 0.72);
        let speedFactor = 3; // ƒëi·ªÅu khi·ªÉn t·ªëc ƒë·ªô di chuy·ªÉn c·∫£nh (kh√¥ng ph·∫£i t·ªëc ƒë·ªô b√°nh xe)
        let paused = false;

        // T·∫°o c√°c ng√¥i nh√† (v·ªã tr√≠ x, chi·ªÅu r·ªông, m√†u)
        const houses = [];
        function generateHouses() {
            houses.length = 0;
            let x = -200;
            while (x < W + 800) {
                const w = 100 + Math.floor(Math.random() * 160);
                const h = 80 + Math.floor(Math.random() * 180);
                const color = randomHouseColor();
                houses.push({ x, w, h, color });
                x += w + 60 + Math.random() * 160;
            }
        }

        function randomHouseColor() {
            const palette = ['#f28b82', '#fbbc04', '#fff475', '#ccff90', '#a7ffeb', '#cbf0f8', '#aecbfa', '#d7aefb'];
            return palette[Math.floor(Math.random() * palette.length)];
        }

        generateHouses();

        // Tr·∫°ng th√°i ng∆∞·ªùi l√°i xe (ch·ªâ 1 ng∆∞·ªùi que) - ƒë·∫∑t ·ªü t·ªâ l·ªá so v·ªõi canvas
        let rider = {
            x: Math.floor(W * 0.2),
            y: roadY - 28,
            vx: 0,
            wheelAngle: 0
        };

        // Bi·∫øn ƒë·ªÉ di chuy·ªÉn c·∫£nh (t·ª©c l√† nh√† ch·∫°y qua tr√°i gi·ªëng ng∆∞·ªùi ƒëi v·ªÅ ph·∫£i)
        let worldOffset = 0;

        // V·∫Ω ƒë∆∞·ªùng
        function drawRoad() {
            // ƒë∆∞·ªùng
            ctx.fillStyle = '#3a3a3a';
            ctx.fillRect(0, roadY, W, H - roadY);
            // v·∫°ch gi·ªØa
            ctx.fillStyle = '#ffd';
            const dashW = 60;
            for (let i = -worldOffset % (dashW * 2); i < W; i += dashW * 2) {
                ctx.fillRect(i + 20, roadY + 28, dashW, 8);
            }
        }

        // V·∫Ω nh√† (ƒë∆°n gi·∫£n: th√¢n + m√°i + c·ª≠a s·ªï)
        function drawHouse(h) {
            const baseY = roadY - 8;
            // th√¢n nh√†
            ctx.fillStyle = h.color;
            ctx.fillRect(h.x + worldOffset, baseY - h.h, h.w, h.h);
            // m√°i tam gi√°c
            ctx.fillStyle = '#7b3e19';
            ctx.beginPath();
            ctx.moveTo(h.x + worldOffset - 6, baseY - h.h);
            ctx.lineTo(h.x + worldOffset + h.w / 2, baseY - h.h - 30);
            ctx.lineTo(h.x + worldOffset + h.w + 6, baseY - h.h);
            ctx.closePath();
            ctx.fill();
            // c·ª≠a s·ªï
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            const ws = 16;
            const wx = h.x + worldOffset + 12;
            const wy = baseY - h.h + 18;
            ctx.fillRect(wx, wy, ws, ws);
            ctx.fillRect(wx + 36, wy, ws, ws);
            // c·ª≠a
            ctx.fillStyle = '#5a2e1a';
            ctx.fillRect(h.x + worldOffset + h.w - 36, baseY - 36, 24, 36);
        }

        // V·∫Ω ng∆∞·ªùi que + xe m√°y
        function drawRider(t) {
            const x = rider.x;
            const y = rider.y;
            const wheelRadius = 16;
          
            const backX = x - 18;
            const frontX = x + 28;
            const wheelY = y + 22;
          
            // --- B√°nh xe ---
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#111';
            ctx.beginPath();
            ctx.arc(backX, wheelY, wheelRadius, 0, Math.PI * 2);
            ctx.stroke();
          
            ctx.beginPath();
            ctx.arc(frontX, wheelY, wheelRadius, 0, Math.PI * 2);
            ctx.stroke();
          
            // --- Th√¢n xe ---
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#333';
            ctx.beginPath();
            ctx.moveTo(backX, wheelY - 2);
            ctx.lineTo(x + 8, y - 4);
            ctx.lineTo(frontX, wheelY - 2);
            ctx.stroke();
          
            // --- Ghi-ƒë√¥ng ---
            ctx.beginPath();
            ctx.moveTo(x + 8, y - 4);
            ctx.lineTo(x + 36, y - 16);
            ctx.lineTo(x + 44, y - 10);
            ctx.stroke();
          
            // --- Th√¢n xe ch√≠nh (kh·ªëi th√¢n) ---
            ctx.fillStyle = '#222';
            ctx.fillRect(x - 4, y - 10, 14, 4);
          
            // --- ƒê√®n xe ---
            ctx.beginPath();
            ctx.arc(x + 30, y - 16, 3, 0, Math.PI * 2);
            ctx.fill();
          
            // --- Ng∆∞·ªùi que ---
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#000';
          
            // ƒë·∫ßu
            ctx.beginPath();
            ctx.arc(x - 6, y - 50, 7, 0, Math.PI * 2);
            ctx.fillStyle = '#ffe0bd';
            ctx.fill();
            ctx.stroke();
          
            // th√¢n
            ctx.beginPath();
            ctx.moveTo(x - 6, y - 45);
            ctx.lineTo(x - 6, y - 25);
            ctx.stroke();
          
            // tay
            ctx.beginPath();
            ctx.moveTo(x - 6, y - 26);
            ctx.lineTo(x + 30, y - 20);
            ctx.stroke();
          
            // ch√¢n
            ctx.beginPath();
            ctx.moveTo(x - 5, y - 31);
            ctx.lineTo(x - 18, y + 14);
            ctx.stroke();
          
            ctx.beginPath();
            ctx.moveTo(x - 5, y - 31);
            ctx.lineTo(x + 8, y + 13);
            ctx.stroke();
          
            // --- Hi·ªáu ·ª©ng nan b√°nh ---
            const drawSpokes = (cx, cy) => {
              ctx.save();
              ctx.translate(cx, cy);
              ctx.rotate(rider.wheelAngle);
              for (let i = 0; i < 6; i++) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(
                  wheelRadius * Math.cos((i * Math.PI) / 3),
                  wheelRadius * Math.sin((i * Math.PI) / 3)
                );
                ctx.stroke();
              }
              ctx.restore();
            };
          
            drawSpokes(backX, wheelY);
            drawSpokes(frontX, wheelY);
        }

        // V·∫Ω background (m·ªôt v√†i ƒë√°m m√¢y ƒë∆°n gi·∫£n)
        function drawSky(t) {
            // m√¢y di chuy·ªÉn ch·∫≠m
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            const cloudCount = 5;
            for (let i = 0; i < cloudCount; i++) {
                const cx = ((i * 300) - worldOffset * 0.2) % (W + 400) - 100;
                const cy = 60 + (i % 2) * 20;
                drawCloud(cx, cy);
            }
        }
        function drawCloud(cx, cy) {
            ctx.beginPath();
            ctx.ellipse(cx, cy, 40, 20, 0, 0, Math.PI * 2);
            ctx.ellipse(cx + 30, cy + 6, 30, 18, 0, 0, Math.PI * 2);
            ctx.ellipse(cx - 30, cy + 6, 30, 18, 0, 0, Math.PI * 2);
            ctx.fill();
        }

         // üëâ Th√™m hi·ªáu ·ª©ng m∆∞a
         const raindrops = [];
        const RAIN_COUNT = 180; // s·ªë gi·ªçt m∆∞a
        function initRain() {
            raindrops.length = 0;
            for (let i = 0; i < RAIN_COUNT; i++) {
                raindrops.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    len: 10 + Math.random() * 18,
                    speed: 200 + Math.random() * 300,
                    opacity: 0.4 + Math.random() * 0.5
                });
            }
        }
        initRain();
    
        function drawRain(dt) {
            ctx.strokeStyle = 'rgba(180,180,255,0.7)';
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            for (let drop of raindrops) {
                drop.y += drop.speed * dt;
                if (drop.y > H) {
                    drop.y = -drop.len;
                    drop.x = Math.random() * W;
                }
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x + 2, drop.y + drop.len);
            }
            ctx.stroke();
        }
    
        // --- override l·∫°i v√≤ng l·∫∑p frame() ---
        let last = performance.now();
        function frame(now) {
            const dt = (now - last) / 1000;
            last = now;
            if (!paused) {
                worldOffset -= speedFactor * 60 * dt;
                if (worldOffset < -1000) worldOffset += 1000;
                rider.wheelAngle -= speedFactor * 2.4 * dt;
            }
    
            ctx.clearRect(0, 0, W, H);
            drawSky(now);
            ctx.fillStyle = '#e6f2e6';
            ctx.fillRect(0, roadY - 130, W, 130);
            for (const h of houses) {
                if (h.x + worldOffset + h.w < -200 || h.x + worldOffset > W + 200) continue;
                drawHouse(h);
            }
            drawRoad();
            drawRider(now);
            if (houses.length) {
                const first = houses[0];
                if (first.x + worldOffset + first.w < -300) {
                    houses.shift();
                    const last = houses[houses.length - 1];
                    const newX = last.x + last.w + 60 + Math.random() * 140;
                    houses.push({ x: newX, w: 100 + Math.floor(Math.random() * 160), h: 80 + Math.floor(Math.random() * 180), color: randomHouseColor() });
                }
            }
    
            // ‚òî Th√™m g·ªçi v·∫Ω m∆∞a
            drawRain(dt);
    
            requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);

        // Main loop
        function frame(now) {
            const dt = (now - last) / 1000; // seconds
            last = now;
            if (!paused) {
                // c·∫≠p nh·∫≠t th·∫ø gi·ªõi: di chuy·ªÉn c·∫£nh sang tr√°i
                worldOffset -= speedFactor * 60 * dt; // px/s roughly
                // n·∫øu nh√† ƒë√£ ƒëi h·∫øt b√™n tr√°i th√¨ t√°i t·∫°o chu·ªói nh√† ·ªü ph·∫£i
                if (worldOffset < -1000) {
                    worldOffset += 1000; // gi·ªØ cho offset kh√¥ng qu√° l·ªõn
                }
                // b√°nh xe xoay
                rider.wheelAngle -= speedFactor * 2.4 * dt;
            }

            // x√≥a
            ctx.clearRect(0, 0, W, H);

            // v·∫Ω b·∫ßu tr·ªùi & m√¢y
            drawSky(now);

            // v·∫Ω m·∫∑t ƒë·∫•t 1 l·ªõp xa (ƒë·ªìi) ƒë·ªÉ t·∫°o chi·ªÅu s√¢u
            ctx.fillStyle = '#e6f2e6';
            ctx.fillRect(0, roadY - 130, W, 130);

            // v·∫Ω houses
            for (const h of houses) {
                // skip houses qu√° xa b√™n tr√°i ho·∫∑c ph·∫£i
                if (h.x + worldOffset + h.w < -200 || h.x + worldOffset > W + 200) continue;
                drawHouse(h);
            }

            // v·∫Ω ƒë∆∞·ªùng
            drawRoad();

            // v·∫Ω ng∆∞·ªùi l√°i xe (lu√¥n ·ªü v·ªã tr√≠ c·ªë ƒë·ªãnh tr√™n canvas)
            drawRider(now);

            // c·∫≠p nh·∫≠t: n·∫øu houses di chuy·ªÉn ra kh·ªèi m√†n h√¨nh (b√™n tr√°i) th√¨ thay b·∫±ng ng√¥i nh√† m·ªõi ·ªü b√™n ph·∫£i
            // ƒë∆°n gi·∫£n: n·∫øu nh√† ƒë·∫ßu ti√™n ra kh·ªèi tr√°i th√¨ push m·ªôt nh√† m·ªõi b√™n ph·∫£i
            if (houses.length) {
                const first = houses[0];
                if (first.x + worldOffset + first.w < -300) {
                    // remove first and th√™m 1 nh√† m·ªõi ·ªü cu·ªëi
                    houses.shift();
                    const last = houses[houses.length - 1];
                    const newX = last.x + last.w + 60 + Math.random() * 140;
                    houses.push({ x: newX, w: 100 + Math.floor(Math.random() * 160), h: 80 + Math.floor(Math.random() * 180), color: randomHouseColor() });
                }
            }

            requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);

        // UI: t·∫°m d·ª´ng v√† ƒëi·ªÅu ch·ªânh t·ªëc ƒë·ªô
        const btn = document.getElementById('toggle');
        btn.addEventListener('click', () => {
            paused = !paused;
            btn.textContent = paused ? 'Ti·∫øp t·ª•c' : 'T·∫°m d·ª´ng';
        });
        document.getElementById('speed').addEventListener('input', (e) => {
            speedFactor = Number(e.target.value);
            document.getElementById('spdVal').textContent = speedFactor;
        });

        // G·ª£i √Ω: b·∫°n c√≥ th·ªÉ thay ƒë·ªïi k√≠ch th∆∞·ªõc ng∆∞·ªùi, m√†u nh√† ho·∫∑c th√™m chi ti·∫øt.

    </script>
    
</body>

</html>